<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Announcing rtc 0.5.0: Simulcast Support and API Refinements">
  <link rel="icon" href="../../../../res/webrtc.rs.ico">
  <link rel="stylesheet" href="../../../../res/all.css">
  <link rel="stylesheet" href="../../../../res/bulma.min.css">
  <link rel="stylesheet" type="text/css" href="../../../../res/notie.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <style>
    .blog-content {
      max-width: 800px;
      margin: 0 auto;
      line-height: 1.7;
    }

    .blog-content h1 {
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 1rem;
      color: #363636;
    }

    .blog-content h2 {
      font-size: 1.5rem;
      font-weight: 600;
      margin-top: 2rem;
      margin-bottom: 1rem;
      color: #363636;
    }

    .blog-content h3 {
      font-size: 1.25rem;
      font-weight: 600;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      color: #363636;
    }

    .blog-content h4 {
      font-size: 1.1rem;
      font-weight: 600;
      margin-top: 1.25rem;
      margin-bottom: 0.5rem;
      color: #363636;
    }

    .blog-content p {
      margin-bottom: 1rem;
    }

    .blog-content ul {
      margin-bottom: 1rem;
      margin-left: 2rem;
      list-style-type: disc;
    }

    .blog-content li {
      margin-bottom: 0.5rem;
    }

    .blog-content pre {
      background-color: #282c34;
      padding: 1rem;
      border-radius: 5px;
      overflow-x: auto;
      margin-bottom: 1rem;
    }

    .blog-content code {
      background-color: #f5f5f5;
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
    }

    .blog-content pre code {
      background-color: transparent;
      padding: 0;
    }

    .blog-content strong {
      font-weight: 600;
    }

    .blog-content hr {
      margin: 2rem 0;
      border: none;
      border-top: 1px solid #dbdbdb;
    }

    .blog-meta {
      color: #777;
      font-size: 0.9rem;
      margin-bottom: 2rem;
      display: flex;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .view-count {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .view-count svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
    }
  </style>
  <title>Announcing rtc 0.5.0: Simulcast Support and API Refinements | WebRTC.rs</title>
</head>

<body>
  <nav class="navbar is-dark" style="z-index:1">
    <div class="container">
      <div class="navbar-brand">
        <a class="navbar-item" href="https://github.com/webrtc-rs"><img src="../../../../res/Github.png" height="28"></a>
        <a class="navbar-item" href="https://github.com/webrtc-rs/webrtc"><img src="../../../../res/webrtc.rs.ico" width="28" height="28"><strong>&nbsp;WebRTC</strong></a>
        <a class="navbar-item" href="https://github.com/webrtc-rs/rtc"><img src="../../../../res/rtc.ico" width="28" height="28"><strong>&nbsp; RTC</strong></a>
        <a class="navbar-item" href="https://github.com/webrtc-rs/sfu"><img src="../../../../res/sfu-rs.ico" width="28" height="28"><strong>&nbsp; SFU</strong></a>
        <a class="navbar-item" href="https://github.com/webrtc-rs/sansio"><img src="../../../../res/sansio.ico" width="28" height="28"><strong>&nbsp; SansIO</strong></a>
        <div class="navbar-item">
          <iframe src="https://github.com/sponsors/webrtc-rs/button" title="Sponsor webrtc-rs" height="35" width="116"
            style="border: 0;"></iframe>
        </div>
      </div>
      <div class="navbar-menu">
        <div class="navbar-end">
          <a class="navbar-item" href="../../../index.html"><strong>üìù Blog &nbsp;&nbsp; </strong></a>
          <a class="navbar-item" href="../../../../index.html"><strong>üè† Home &nbsp;&nbsp; </strong></a>
        </div>
      </div>
    </div>
  </nav>
  <dev class="section">
    <div class="container">
      <article class="message is-success">
        <div class="message-body">
          <div class="blog-content">
            

<h1>Announcing <code>rtc</code> 0.5.0: Simulcast Support and API Refinements üéâ</h1>
<div class="blog-meta">
  <span>January 6, 2026</span>
  <img src="https://hits.sh/webrtc-rs.github.io/blog/2026/01/05/announcing-rtc-v0.5.0.svg?style=flat-square&label=views&color=777" alt="views" style="vertical-align: middle;"/>
</div>
            
<p>We're excited to announce <strong><code>rtc</code> 0.5.0</strong>, a major release that brings <strong>simulcast support</strong>, API improvements, and enhanced documentation to our sans-I/O WebRTC implementation.</p>
<h2>What's New in 0.5.0</h2>
<h3>Simulcast Support üìπ</h3>
<p>The headline feature is <strong>simulcast support</strong>. Simulcast enables sending multiple quality levels (spatial or temporal layers) of the same video stream simultaneously, allowing adaptive bitrate streaming and improved user experience across varying network conditions.</p>
<p><strong>Key capabilities:</strong></p>
<ul>
<li>Multiple spatial layers per video track (e.g., quarter/half/full resolution)</li>
<li>RTP Stream ID (RID) for layer identification</li>
<li>Dynamic layer selection and switching</li>
<li>Proper RTP header extension handling (<code>mid</code>, <code>rtp-stream-id</code>, <code>repaired-rtp-stream-id</code>)</li>
</ul>
<p><strong>Example use cases:</strong></p>
<ul>
<li>Video conferencing with quality adaptation</li>
<li>Live streaming with bandwidth-aware layer selection</li>
<li>Multi-party calls with selective forwarding</li>
</ul>
<h3>New Examples</h3>
<p>Both examples demonstrate the sans-I/O event loop pattern and follow the same architectural principles.</p>
<h4>Simulcast Example</h4>
<p>The <a href="https://github.com/webrtc-rs/rtc/tree/master/examples/examples/simulcast">simulcast example</a> shows how to send video with three quality layers and dynamically forward different layers based on bandwidth or CPU constraints:</p>
<pre><code class="language-rust">
// Configure three spatial layers
let layers = vec![
    RTCRtpEncodingParameters {
        rtp_coding_parameters: RTCRtpCodingParameters {
            rid: &quot;q&quot;.to_string(),  // quarter resolution
            ssrc: Some(100),
            ..Default::default()
        },
        codec: vp8_codec.clone(),
        ..Default::default()
    },
    RTCRtpEncodingParameters {
        rtp_coding_parameters: RTCRtpCodingParameters {
            rid: &quot;h&quot;.to_string(),  // half resolution
            ssrc: Some(200),
            ..Default::default()
        },
        codec: vp8_codec.clone(),
        ..Default::default()
    },
    RTCRtpEncodingParameters {
        rtp_coding_parameters: RTCRtpCodingParameters {
            rid: &quot;f&quot;.to_string(),  // full resolution
            ssrc: Some(300),
            ..Default::default()
        },
        codec: vp8_codec.clone(),
        ..Default::default()
    },
];
</code></pre>
<p>The example handles RID-based routing, sends periodic keyframe requests (PLI), and demonstrates proper header extension configuration.</p>
<h4>Swap Tracks Example</h4>
<p>The <a href="https://github.com/webrtc-rs/rtc/tree/master/examples/examples/swap-tracks">swap-tracks example</a> demonstrates smooth switching between multiple incoming video tracks:</p>
<ul>
<li>Automatic keyframe requests when switching tracks</li>
<li>Proper timestamp and sequence number handling</li>
<li>Continuous output stream without artifacts</li>
</ul>
<p>This pattern is essential for implementing features like speaker switching in video conferences.</p>
<hr>
<h2>API Changes</h2>
<p>To properly support simulcast, several APIs have been refined. These are <strong>breaking changes</strong> that make the API more powerful and consistent with multi-encoding scenarios.</p>
<h3>MediaStreamTrack Constructor</h3>
<p>The constructor now accepts a vector of decoding parameters instead of individual fields:</p>
<p><strong>Before:</strong></p>
<pre><code class="language-rust">
MediaStreamTrack::new(
    stream_id,
    track_id,
    label,
    kind,
    rid: Option&lt;String&gt;,
    ssrc: u32,
    codec: RTCRtpCodec,
)
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-rust">
MediaStreamTrack::new(
    stream_id,
    track_id,
    label,
    kind,
    codings: Vec&lt;RTCRtpEncodingParameters&gt;,
)
</code></pre>
<p>This design naturally supports multiple encodings:</p>
<pre><code class="language-rust">
let track = MediaStreamTrack::new(
    &quot;stream-id&quot;.to_string(),
    &quot;track-id&quot;.to_string(),
    &quot;Video Track&quot;.to_string(),
    RtpCodecKind::Video,
    vec![RTCRtpEncodingParameters {
        rtp_coding_parameters: RTCRtpCodingParameters {
            ssrc: Some(12345),
            rid: &quot;q&quot;.to_string(),
            ..Default::default()
        },
        codec,
        ..Default::default()
    }],
);
</code></pre>
<h3>Single Value ‚Üí Iterator Methods</h3>
<p>Several methods now return iterators to support multiple values in simulcast:</p>
<pre><code class="language-rust">
// Old API
let ssrc = track.ssrc();
let codec = track.codec();

// New API - iterate over all encodings
for ssrc in track.ssrcs() {
    if let Some(codec) = track.codec(ssrc) {
        println!(&quot;SSRC {}: {}&quot;, ssrc, codec.mime_type);
    }
}

// Or get first value
let ssrc = track.ssrcs().next().unwrap_or(0);
let codec = track.codecs().next().unwrap();
</code></pre>
<p><strong>New simulcast-aware methods:</strong></p>
<pre><code class="language-rust">
// Get RID for specific SSRC
if let Some(rid) = track.rid(ssrc) {
    println!(&quot;Layer: {}&quot;, rid);
}

// Get codec for specific SSRC
if let Some(codec) = track.codec(ssrc) {
    println!(&quot;Codec: {}&quot;, codec.mime_type);
}
</code></pre>
<h3>Simplified RTCRtpReceiver</h3>
<p>The receiver API is now simpler - each receiver has exactly one track:</p>
<pre><code class="language-rust">
// Old API
let track = receiver.track(&amp;track_id)?;
if let Some(track) = track {
    // use track
}

// New API
let track = receiver.track()?;
// use track directly
</code></pre>
<h3>New Types</h3>
<ul>
<li><strong><code>RtpStreamId</code></strong> - Type alias for RTP stream identifiers (e.g., "q", "h", "f")</li>
<li><strong><code>RepairedStreamId</code></strong> - Type alias for redundancy stream identifiers</li>
</ul>
<p>Both follow <a href="https://www.rfc-editor.org/rfc/rfc8852.html">RFC 8852</a> semantics.</p>
<hr>
<h2>Documentation Improvements</h2>
<p>Comprehensive documentation has been added for all simulcast-related APIs:</p>
<ul>
<li><strong>222+ passing doc tests</strong> (up from 218 in v0.3.0)</li>
<li>Detailed examples for every changed API</li>
<li>Clear migration guides with before/after code</li>
<li>Proper RFC and W3C specification references</li>
<li>Real-world usage patterns</li>
</ul>
<p><strong>Newly documented types:</strong></p>
<ul>
<li><code>RTCRtpEncodingParameters</code> - Complete simulcast layer configuration</li>
<li><code>RTCRtpCodingParameters</code> - RTP-level parameters (SSRC, RID, RTX, FEC)</li>
<li><code>RTCRtpRtxParameters</code> - Retransmission stream configuration</li>
<li><code>RTCRtpFecParameters</code> - Forward error correction configuration</li>
<li><code>RTCTrackEventInit::rid</code> - Simulcast stream identification in track events</li>
</ul>
<p>Each type includes practical examples demonstrating single-encoding and multi-encoding scenarios.</p>
<hr>
<h2>Migration Guide</h2>
<h3>Updating MediaStreamTrack Construction</h3>
<pre><code class="language-rust">
// Old code (v0.3.x)
use rtc::media_stream::MediaStreamTrack;

let track = MediaStreamTrack::new(
    stream_id,
    track_id,
    &quot;Video&quot;.to_string(),
    RtpCodecKind::Video,
    None,   // rid
    12345,  // ssrc
    codec,
);

// New code (v0.4.0)
use rtc::media_stream::MediaStreamTrack;
use rtc::rtp_transceiver::rtp_sender::{RTCRtpEncodingParameters, RTCRtpCodingParameters};

let track = MediaStreamTrack::new(
    stream_id,
    track_id,
    &quot;Video&quot;.to_string(),
    RtpCodecKind::Video,
    vec![RTCRtpEncodingParameters {
        rtp_coding_parameters: RTCRtpCodingParameters {
            ssrc: Some(12345),
            ..Default::default()
        },
        codec,
        ..Default::default()
    }],
);
</code></pre>
<h3>Updating Method Calls</h3>
<pre><code class="language-rust">
// ssrc() ‚Üí ssrcs()
let ssrc = track.ssrc();  // Old
let ssrc = track.ssrcs().next().unwrap_or(0);  // New

// codec() ‚Üí codecs() or codec(ssrc)
let codec = track.codec();  // Old
let codec = track.codecs().next().unwrap();  // New
// Or for specific SSRC:
let codec = track.codec(ssrc).unwrap();  // New

// rid() now requires SSRC
let rid = track.rid();  // Old
let ssrc = track.ssrcs().next().unwrap();
let rid = track.rid(ssrc);  // New

// receiver.track() simplified
let track = receiver.track(&amp;track_id)?.unwrap();  // Old
let track = receiver.track()?;  // New
</code></pre>
<h3>Working with Simulcast</h3>
<pre><code class="language-rust">
// Iterate over all layers
for ssrc in track.ssrcs() {
    if let Some(rid) = track.rid(ssrc) {
        if let Some(codec) = track.codec(ssrc) {
            println!(&quot;Layer {}: SSRC {} using {}&quot;, 
                rid, ssrc, codec.mime_type);
        }
    }
}
</code></pre>
<hr>
<h2>Architecture & Implementation</h2>
<h3>Sans-I/O Event Loop</h3>
<p>All examples follow the consistent sans-I/O pattern described in the <a href="../04/announcing-rtc-v0.3.0.md">v0.3.0 announcement</a>:</p>
<pre><code class="language-rust">
&#x27;EventLoop: loop {
    // 1. Send outgoing packets
    while let Some(msg) = pc.poll_write() {
        socket.send_to(&amp;msg.message, msg.transport.peer_addr).await?;
    }

    // 2. Handle state changes
    while let Some(event) = pc.poll_event() {
        match event {
            RTCPeerConnectionEvent::OnTrack(track_event) =&gt; {
                // Handle incoming tracks with simulcast info
                if let Some(rid) = &amp;track_event.rid {
                    println!(&quot;Simulcast layer: {}&quot;, rid);
                }
            }
            _ =&gt; {}
        }
    }

    // 3. Process RTP/RTCP/DataChannel messages
    while let Some(message) = pc.poll_read() {
        match message {
            RTCMessage::RtpPacket(track_id, packet) =&gt; {
                // Process RTP packets
            }
            _ =&gt; {}
        }
    }

    // 4. Multiplex I/O
    tokio::select! {
        _ = tokio::time::sleep(delay) =&gt; {
            pc.handle_timeout(Instant::now())?;
        }
        Ok((n, peer_addr)) = socket.recv_from(&amp;mut buf) =&gt; {
            pc.handle_read(tagged_bytes)?;
        }
    }
}
</code></pre>
<h3>Internal Improvements</h3>
<ul>
<li><strong>Enhanced endpoint handler</strong> - Proper mid/rid header extension processing</li>
<li><strong>Better track lifecycle management</strong> - Robust handling of simulcast track events</li>
<li><strong>Improved SSRC-to-codec mapping</strong> - Efficient lookups for multi-encoding tracks</li>
<li><strong>Header extension support</strong> - Full implementation of <a href="https://www.rfc-editor.org/rfc/rfc8285.html">RFC 8285</a></li>
</ul>
<hr>
<h2>What's Next: Interceptors üöÄ</h2>
<p>The next major milestone is <strong>Interceptor support</strong> for advanced RTCP handling and quality control.</p>
<p><strong>Planned capabilities:</strong></p>
<ul>
<li>Custom RTCP packet processing pipeline</li>
<li>Real-time statistics collection (packet loss, jitter, RTT)</li>
<li>Bandwidth estimation algorithms (GCC, Transport-CC)</li>
<li>Adaptive bitrate control</li>
<li>Custom QoS policies and congestion control</li>
</ul>
<p><strong>Use cases:</strong></p>
<ul>
<li>Network quality monitoring and diagnostics</li>
<li>Adaptive simulcast layer selection based on bandwidth</li>
<li>Custom retransmission strategies</li>
<li>Performance analytics and observability</li>
</ul>
<p>The interceptor framework will be implemented using the same <code>sansio::Protocol</code> pattern, maintaining transport independence and testability. See the <a href="../04/building-webrtc-pipeline-with-sansio.md">pipeline architecture article</a> for details on how handlers compose.</p>
<hr>
<h2>Getting Started</h2>
<h3>Installation</h3>
<pre><code class="language-toml">
[dependencies]
rtc = &quot;0.5.0&quot;
</code></pre>
<h3>Quick Example</h3>
<pre><code class="language-rust">
use rtc::peer_connection::RTCPeerConnection;
use rtc::peer_connection::configuration::RTCConfigurationBuilder;
use rtc::sansio::Protocol;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let config = RTCConfigurationBuilder::new().build();
    let mut pc = RTCPeerConnection::new(config)?;

    // Create and set local description
    let offer = pc.create_offer(None)?;
    pc.set_local_description(offer)?;

    // Sans-I/O event loop
    loop {
        while let Some(msg) = pc.poll_write() {
            // Send to network
        }
        
        while let Some(event) = pc.poll_event() {
            // Handle state changes
        }
        
        while let Some(message) = pc.poll_read() {
            // Process application messages
        }
        
        // Handle I/O and timeouts
        // ...
    }
}
</code></pre>
<p>Check out the <a href="https://github.com/webrtc-rs/rtc/tree/master/examples">examples directory</a> for complete working code!</p>
<hr>
<h2>Feature Parity Update</h2>
<p>Progress toward full feature parity with the <code>webrtc</code> crate:</p>
<p>‚úÖ <strong>Complete:</strong></p>
<ul>
<li>ICE, DTLS, SRTP/SRTCP, SCTP</li>
<li>Data Channels (reliable & unreliable)</li>
<li>RTP/RTCP, Media Tracks, SDP</li>
<li>Peer Connection API</li>
<li><strong>Simulcast</strong> ‚Üê New in 0.5.0!</li>
</ul>
<p>üöß <strong>In Progress:</strong></p>
<ul>
<li>RTCP Interceptors (next release)</li>
</ul>
<hr>
<h2>Links</h2>
<ul>
<li><strong>GitHub</strong>: https://github.com/webrtc-rs/rtc</li>
<li><strong>Crate</strong>: https://crates.io/crates/rtc</li>
<li><strong>Docs</strong>: https://docs.rs/rtc</li>
<li><strong>Discord</strong>: https://discord.gg/4Ju8UHdXMs</li>
<li><strong>Examples</strong>: https://github.com/webrtc-rs/rtc/tree/master/examples</li>
</ul>
<hr>
<h2>Full Changelog</h2>
<h3>Added</h3>
<ul>
<li>‚ú® Full simulcast support with multiple spatial layers</li>
<li>‚ú® RTP stream identifier (RID) support per RFC 8852</li>
<li>‚ú® Header extension handling (mid, rtp-stream-id, repaired-rtp-stream-id)</li>
<li>‚ú® Simulcast example with three quality layers</li>
<li>‚ú® Swap-tracks example with smooth track switching</li>
<li>‚ú® <code>MediaStreamTrack::codec(ssrc)</code> method for per-encoding codec lookup</li>
<li>‚ú® <code>RtpStreamId</code> and <code>RepairedStreamId</code> type aliases</li>
</ul>
<h3>Changed</h3>
<ul>
<li>üí• <code>MediaStreamTrack::new()</code> - Consolidated into <code>Vec&lt;RTCRtpEncodingParameters&gt;</code></li>
<li>üí• <code>MediaStreamTrack::ssrc()</code> ‚Üí <code>ssrcs()</code> - Returns iterator</li>
<li>üí• <code>MediaStreamTrack::codec()</code> - Now requires SSRC parameter</li>
<li>üí• <code>MediaStreamTrack::rid()</code> - Now requires SSRC parameter</li>
<li>üí• <code>RTCRtpReceiver::track()</code> - Removed track_id parameter, simplified return</li>
</ul>
<h3>Improved</h3>
<ul>
<li>üìö 222+ doc tests with comprehensive examples</li>
<li>üìö Complete documentation for RTCRtpEncodingParameters</li>
<li>üìö Complete documentation for RTCRtpCodingParameters</li>
<li>üìö Enhanced RTCTrackEventInit::rid documentation</li>
<li>üèóÔ∏è Improved endpoint handler for RTP header extensions</li>
<li>üèóÔ∏è Better internal track lifecycle management</li>
</ul>
<h3>Fixed</h3>
<ul>
<li>üêõ Receiver tracks hashmap handling</li>
<li>üêõ SSRC-to-codec mapping in simulcast scenarios</li>
<li>üêõ Header extension processing</li>
</ul>
<hr>
<h2>Relationship with <code>webrtc</code> Crate</h2>
<p>As stated in the <a href="../04/announcing-rtc-v0.3.0.md">v0.3.0 announcement</a>, <code>rtc</code> (sans-I/O) and <code>webrtc</code> (async) are <strong>complementary</strong>:</p>
<ul>
<li><strong>Use <code>webrtc</code></strong> for quick start with Tokio and async/await</li>
<li><strong>Use <code>rtc</code></strong> for runtime independence, custom I/O, or maximum control</li>
</ul>
<p>Both crates are actively maintained and share protocol implementations where possible.</p>
<hr>
<p><em>Thanks to everyone who contributed feedback, bug reports, and feature requests! Special thanks to the WebRTC-rs community for making this release possible.</em> ü¶Ä</p>
<p>Feedback and contributions welcome on <a href="https://github.com/webrtc-rs/rtc">GitHub</a>!</p>

            <hr>
            <p style="text-align: center;">
              <a href="../../../index.html">‚Üê Back to Blog</a> | <a href="../../../../index.html">Home</a>
            </p>
          </div>
        </div>
      </article>
    </div>
  </dev>
  <div class="container has-text-centered">
      <img src="../../../../res/animated_ferris_white.gif">
  </div>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/rust.min.js"></script>
<script>hljs.highlightAll();</script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-BHTZSJEX72"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-BHTZSJEX72');
</script>
</html>